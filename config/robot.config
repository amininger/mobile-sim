//This file holds ALL constants, configurations that the magic system needs

robot{
    dflt_status_rate = 2.0;
    cmds_timeout_sec = 10;
    orcRight = "192.168.237.7";
    orcLeft = "192.168.237.8";

    // gui battery limits (v)
    batteryMin  = 24.0;
    batteryWarn = 25.0;
    batteryMax  = 27.0;

    // orc hinge should be on right, but the squat bot has hinge on left
    orcHinge = "192.168.237.7";

    geometry {
        width  = 0.25;
        radius = 0.40;
        circles_x = [0.13335];
        circles_y = [0.00000];

        centerOffsetX_m = 0.13335;            // Half the axle separation
    }

    // Kinet positional offsets from robot center
    kinect {
        xoff = 0.140;
        yoff = 0.000;
        zoff = 0.565;
    }

    driver {
        // don't honor CMDS older than this.  Includes budget account
        // for inter-robot time synchronization.
	    cmd_timeout = 10;
    }
}

kinect {
    min_range = .25;
    max_range = 5;
}

alarm {
    startupInhibitTime = 15.0; // inhibit alarms for this many seconds after startup.
    repeatInhibitTime = 8.0;   // don't repeat alarms faster than this (per event)
    maxAlarms = 5; // don't alarm more than this many times (per event)
    espeakVoice = "english:p90:a200";

    batteryVoltage = 25; // minimum battery voltage
    laptopTemp = 95; // maximum deg C.
    orcTimeout = 2; // maximum seconds since we last heard from an orc
    orcRTT = 0.25; // maximum orc round trip time
    orc_version = 2.11;// format: vXX.YY.HASH# (where YY < 99 changes since tag).

    freeMemory = 5000; // minimum KB of free/cache memory available

    // integrate rates over what period? (seconds)
    // (larger values provide more "slush")
    lcm_rates_period = 4.0;

    // min/max rates for LCM channels. (nominal rates in comments for reference)
    lcm_rates {
    	      PIMU = [ 150 300 ];                // 260
	      HOKUYO_LIDAR = [ 30 50 ];         // 40
	      POSE = [ 40 200 ];                // 400
	      MOTOR_FEEDBACK = [ 40 110 ];      // 80
//	      TERRAIN_MAP = [ 0 5 ];            // 1
	      SYSTEM_STATUS = [ .2 5 ];         // 2
	      THUMBS = [ 1 10 ];                // 4
	      AX12_STATUS_HOKUYO = [ 20 100 ];  // 30
	      PROCMAN_PROCESS_LIST = [ 0.2 5 ]; // 1
	      PROCMAN_STATUS_LIST = [ 1 10 ];   // 5
          NMEA = [ 3 40 ];
    }

    BIOS_revision = 1.28;
}

// This node contains information for building the configuration space
// and general path planning.
// Currently we use the simplest possible configuration space model: a
// single circle centered at the center of the robot.
pathPlanning {
    replan_period = 500;                    // ms
    replanOnTerrainMap      = true;
    replanOnNewCommand      = true;
    replanOnNewAnnotation   = true;

    enableWidthCfgSpace     = true;         // defaults to radius when false
    enableGeomAnnotations   = true;         // grid map without oois or geometry

    // terrain map expiration checking
    tmLifetimeChecking      = true;         // Reject terrain maps on age?
    tmLifetime_s            = 4;            // Allowed age of terrain maps in seconds

    // ooi detections
    static_ooi_radius_m = 3;                // Radius for OOI avoidance circle on path planning gridmap
    mobile_ooi_radius_m = 5.75;             // Radius for OOI avoidance circle on path planning gridmap
    ooilifetime_s   = 240.0;                // OOI Detection lifetime in the path planner

    // geometry annotations
    annolifetime_s  = 30;                   // Lifetime of annotation message (expected every ~3sec)

    // cost map and configuration space
    upsample        = 1;                    // Upsample rate from terrain map
    minCellCost     = 40;                   // Min cost per cell in wavefront
    maxCost         = 254;                  // max allowed cost for connected terrain (byte)
    kernelWidth     = 0.5;                  // width of blur kernel in meters
    polyLookahead   = 0.3;                  // Lookahead distance on poly-line path
    troughWidth     = 3.5;                  // Meter width for trough implied by multiple
                                            // waypoints in a command from the ground station

    rotationWeight  = 128;                  // How much should we merge the path with our current yaw?
    rotationWidth   = 0.125;                // Width of kernel rendered at robot pose to constrain yaw
    rotationSigma   = 0.1;                  // Sigma for gaussian on yaw kernel at robot pose

    // path smoothing
    smoothingSteps  = 100;                  // Number of steps for path smoothing
    minDist         = 0.05;                 // Minimum spacing between points on path
    maxDist         = 0.10;                 // Maximum spacing between points on path
    unitStepCost    = 0.0;                  // Allowable cost increase per unit length
    straightDist    = 0.7;                  // Straight-path distance when turn-in-place
                                            //  actions cannot be allowed (e.g. doorways)

    // turn-in-place fixup
    TIPyaw          = 30;                   // turn required at start of path before considered a "turn in place"
    minDistToRobot  = 0.10;                 // beginning of search space in meters
    maxDistToRobot  = 2;                    // end of search space in meters
    maxAngleError   = 60;                   // one-sided width of search space in degrees
    distToObjEps    = 0.10;                 // extra distance out of TIP prohibited area required

    // path arrival
    goalRadius      = 0.5;

    // radio transmission params
    tx {
        untouchedLength     = 3;            // number of points to not touch when downsampling
        minSegmentLength    = 0.5;          // ideal segment length for downsampled path
                                            // (excluding the beginning)
    }
}
softwareUpdate {
    defaultInterface = "wlan0";
}

radio {
    xtend {
        suffix = "_TX";
        hops = [2];
    }
    wifi {
        dev = "tun0";
        suffix = "_FTX";
    }
    udp {
        suffix = "_LTX";
    }
}

time {
    iface = "wlan0";
    setsw = "true"; // Enable setting the software clock
    sethw = "true"; // Enable setting the hardware clock
}

ax12 {
    color = [0, 1, 0];
    orcTimeOffset = 25000;                  // Ax12 and lidar utimes differ
    trackerTimeout = 0.025;                 // Max utime diff between lidar and ax12 msgs
    size = [0.06, 0.06, 0.12];              // size of the AX12 servo
}

safety_monitor {
    tasks_without_monitoring = [6];     // do not monitor in these tasks
}

obstacle {
    use_flat_world = true;              // Use flat world hazard detector

    obstacle_dz_threshold = 0.10;       // dz (meters) that signals and obstacle
    num_buckets_obs_thresh = 7;         // number of buckets full to signal obstacle

    // max_slope of 0.26 is tan(15degrees) (the ramps for contest) (use 0.1 for no ramps)
    // 0.3 is for 16.7degrees (slightly more than 15 degree ramps...
    max_slope = 0.35 ;                   // slope (dy/dx) used for obstacle detection
    max_z_obstacle = 0.5;
    prob_keep_obstacles = 0.90;          // probability of keeping historical costs

    num_iterations = 20;                 // number of iterations through mrf loop
    num_history_sweeps = 50;             // number of historical sweeps to keep around for terrain data
}

pathControl { // See control.Params for details
    maxLookahead_m = 0.60;
    minLookahead_m = 0.10;

    speedPreview_m = 1.5;
    previewDistThresh_m = 0.3;

    maxSpeed_p = 0.95;
    minSpeed_p = 0.35;

    turnRatio_p = 12.0;

    turnInPlaceThresh_deg = 30;
    slowdownDist_m = 0.50;
    destTolerance_m = 0.15;
    minMotorSpeed_p = 0.01;

    minSampleRate_m = 0.02;
    broom_lookahead_m = .6;
    broom_width_m = .6;

    useUnknownChecking = "false";

    path_timeout_s = 1.0;
}

control {
    spoofMode = false;
}

mapRelay {
    terrainChannel = "TERRAIN_MAP_CURRENT"; // No history
    // terrainChannel = "TERRAIN_MAP"; // With history
}

// priority 5 = STATUS message, lower will get spoken no matter what
// priority 5 messages will get skipped if they are old, except the last one
// Note: 5 is the weakest priority -- it is reserved for status messages
espeak {
    priority_thresh = 5;                    // messages above this threshold don't get spoken
    voice_logging = "english";
    priority_logging = 4;
    voice_task = "english";
    priority_status = 5;                    // For any sort of status message

    pronunciation = [ "(?i)status" "stadus"
        "(?i)lidar" "lye-dar"
	"(?i)nmea" "N M E A" ];

    set_volume = true;
}
