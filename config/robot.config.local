// This file holds ALL constants, configurations probcog needs

tag_config = "/home/rgoeddel/lab/probcog/config/tagdb.config.real-cse";

proc_config = "procman/proc.config";

kinect {
    xoff = 0.140;
    yoff = 0.000;
    zoff = 0.565;

    // Sensor calibration
    calib_rgb = "kinect_5_rgb.config";   // This is not our kinect

    // Calibration w.r.t. the robot
    calib_robot = "mobile_kinect_calib.config"; // Should be auto-generated at some point

    min_range = .25;
    max_range = 5;
}

// Mobile robot stuff
robot {
    dflt_status_rate = 2.0;
    cmds_timeout_sec = 10;
    orcRight = "192.168.237.7";
    orcLeft = "192.168.237.8";

    // gui battery limits (v)
    batteryMin  = 24.0;
    batteryWarn = 25.0;
    batteryMax  = 27.0;

    // orc hinge should be on right, but the squat bot has hinge on left
    orcHinge = "192.168.237.7";

    geometry {
        width  = 0.25;
        radius = 0.40;
        circles_x = [0.13335];
        circles_y = [0.00000];

        centerOffsetX_m = 0.13335;            // Half the axle separation
    }

    driver {
        // don't honor CMDS older than this.  Includes budget account
        // for inter-robot time synchronization.
        cmd_timeout = 10;
    }
}

alarm {
    startupInhibitTime = 15.0; // inhibit alarms for this many seconds after startup.
    repeatInhibitTime = 8.0;   // don't repeat alarms faster than this (per event)
    maxAlarms = 5; // don't alarm more than this many times (per event)
    espeakVoice = "english:p90:a200";

    batteryVoltage = 25; // minimum battery voltage
    laptopTemp = 95; // maximum deg C.
    orcTimeout = 2; // maximum seconds since we last heard from an orc
    orcRTT = 0.25; // maximum orc round trip time
    orc_version = 2.11;// format: vXX.YY.HASH# (where YY < 99 changes since tag).

    freeMemory = 5000; // minimum KB of free/cache memory available

    // integrate rates over what period? (seconds)
    // (larger values provide more "slush")
    lcm_rates_period = 4.0;

    // min/max rates for LCM channels. (nominal rates in comments for reference)
    lcm_rates {
          PIMU = [ 150 300 ];                // 260
	      HOKUYO_LIDAR = [ 30 50 ];         // 40
	      POSE = [ 40 200 ];                // 400
	      MOTOR_FEEDBACK = [ 40 110 ];      // 80
//	      TERRAIN_MAP = [ 0 5 ];            // 1
	      SYSTEM_STATUS = [ .2 5 ];         // 2
	      THUMBS = [ 1 10 ];                // 4
	      AX12_STATUS_HOKUYO = [ 20 100 ];  // 30
	      PROCMAN_PROCESS_LIST = [ 0.2 5 ]; // 1
	      PROCMAN_STATUS_LIST = [ 1 10 ];   // 5
          NMEA = [ 3 40 ];
    }

    BIOS_revision = 1.28;
}

// This node contains information for building the configuration space
// and general path planning.
// Currently we use the simplest possible configuration space model: a
// single circle centered at the center of the robot.
pathPlanning {
    replan_period = 500;                    // ms
    replanOnTerrainMap      = true;
    replanOnNewCommand      = true;
    replanOnNewAnnotation   = true;

    enableWidthCfgSpace     = true;         // defaults to radius when false
    enableGeomAnnotations   = true;         // grid map without oois or geometry

    // terrain map expiration checking
    tmLifetimeChecking      = true;         // Reject terrain maps on age?
    tmLifetime_s            = 4;            // Allowed age of terrain maps in seconds

    // ooi detections
    static_ooi_radius_m = 3;                // Radius for OOI avoidance circle on path planning gridmap
    mobile_ooi_radius_m = 5.75;             // Radius for OOI avoidance circle on path planning gridmap
    ooilifetime_s   = 240.0;                // OOI Detection lifetime in the path planner

    // geometry annotations
    annolifetime_s  = 30;                   // Lifetime of annotation message (expected every ~3sec)

    // cost map and configuration space
    upsample        = 1;                    // Upsample rate from terrain map
    minCellCost     = 40;                   // Min cost per cell in wavefront
    maxCost         = 254;                  // max allowed cost for connected terrain (byte)
    kernelWidth     = 0.5;                  // width of blur kernel in meters
    polyLookahead   = 0.3;                  // Lookahead distance on poly-line path
    troughWidth     = 3.5;                  // Meter width for trough implied by multiple
                                            // waypoints in a command from the ground station

    rotationWeight  = 128;                  // How much should we merge the path with our current yaw?
    rotationWidth   = 0.125;                // Width of kernel rendered at robot pose to constrain yaw
    rotationSigma   = 0.1;                  // Sigma for gaussian on yaw kernel at robot pose

    // path smoothing
    smoothingSteps  = 100;                  // Number of steps for path smoothing
    minDist         = 0.05;                 // Minimum spacing between points on path
    maxDist         = 0.10;                 // Maximum spacing between points on path
    unitStepCost    = 0.0;                  // Allowable cost increase per unit length
    straightDist    = 0.7;                  // Straight-path distance when turn-in-place
                                            //  actions cannot be allowed (e.g. doorways)

    // turn-in-place fixup
    TIPyaw          = 30;                   // turn required at start of path before considered a "turn in place"
    minDistToRobot  = 0.10;                 // beginning of search space in meters
    maxDistToRobot  = 2;                    // end of search space in meters
    maxAngleError   = 60;                   // one-sided width of search space in degrees
    distToObjEps    = 0.10;                 // extra distance out of TIP prohibited area required

    // path arrival
    goalRadius      = 0.5;

    // radio transmission params
    tx {
        untouchedLength     = 3;            // number of points to not touch when downsampling
        minSegmentLength    = 0.5;          // ideal segment length for downsampled path
                                            // (excluding the beginning)
    }
}
softwareUpdate {
    defaultInterface = "wlan0";
}

time {
    iface = "wlan0";
    setsw = "true"; // Enable setting the software clock
    sethw = "true"; // Enable setting the hardware clock
}

ax12 {
    color = [0, 1, 0];
    orcTimeOffset = 25000;                  // Ax12 and lidar utimes differ
    trackerTimeout = 0.025;                 // Max utime diff between lidar and ax12 msgs
    size = [0.06, 0.06, 0.12];              // size of the AX12 servo
}

servo_camera_pan : ax12 {
    // XXX use the extrinsic parameters from the camera calibration instead
    position = [ 0.191, 0.0, 0.60];         // in robot frame
    rollpitchyaw_degrees = [0,0,0];         // in robot frame

    servo_num = 3;                          // servo number of I2C bus
    servo_min_angle_degrees = -120;         // minimum allowable angle
    servo_max_angle_degrees = 120;          // maximum allowable angle
    servo_status_period_ms = 25;            // delay on publishing status
    servo_speed = 0.5;
    publish_channel = "AX12_STATUS_PAN";

    // The next two parameters deal with aligning the servo rotational
    // frame to the robot's
    servo_angle_set_zero = 150;             // servo angle in [0,300] for our 0deg
    servo_angle_inverted = false;           // RHR the same as robot frame?
}

servo_camera_tilt: ax12 {
    // XXX use the extrinsic parameters from the camera calibration instead
    position = [ 0.191, 0.0, 0.60];         // in robot frame
    rollpitchyaw_degrees = [0,0,0];         // in robot frame

    servo_num = 2;                          // servo number of I2C bus
    servo_min_angle_degrees = -60;         // minimum allowable angle
    servo_max_angle_degrees = 30;          // maximum allowable angle
    servo_status_period_ms = 25;            // delay on publishing status
    servo_speed = 0.5;
    publish_channel = "AX12_STATUS_TILT";

    // The next two parameters deal with aligning the servo rotational
    // frame to the robot's
    servo_angle_set_zero = 150;             // servo angle in [0,300] for our 0deg
    servo_angle_inverted = true;           // RHR the same as robot frame?
}

servo_hokuyo : ax12 {
    position = [ 0.266, 0.0, 0.476];        // Robot coords of the servo (main axis) at attachment
    rollpitchyaw_degrees = [0,0,0];         // Orientation of servo relative to robot frame
    axis_to_mirror_offset = 0.03;           // Length between rotation axis and sensor mirror

    servo_num = 1;                          // servo number of I2C bus
    servo_min_angle_degrees = -55;          // minimum angle the controller will allow [-55]
    servo_max_angle_degrees = 20;            // maximum angle the controller will allow [20]
    servo_status_period_ms = 25;            // how frequently the servo status is checked and published
    servo_speed = 0.1;                      // servo speed when moving [0.1]
    servo_default_angle_degrees = 0;        // angle the servo is set to when not being told otherwise
    servo_tracking_angle_degrees = 0;       // angle the servo is set to when tracking mobile ooi
    publish_channel = "DYNAMIXEL_STATUS_HOKUYO";

    // The next two parameters deal with aligning the servo rotational
    // frame to the robot's
    servo_angle_set_zero = 150;             // servo angle in [0,300] for our 0deg
    servo_angle_inverted = false;           // RHR the same as robot frame?

    servo_pause_on_tasks = [0, 1];          // servo freezes for these robot tasks
}

camera {
    url = "dc1394://?format=BAYER_RGGB&timestamps-enable=1&white-balance-manual=1&white-balance-red=495&white-balance-blue=612&exposure-manual=0&brightness-manual=0&gamma-manual=1&gamma=1&frame-rate-manual=1&frame-rate=20";

    thumbs {
        hz = 5;
        quality = 0.8;
	    width = 240;
    }

    sync {                                  // SyncErrorDetector1394 settings
        samples         = 10;               // 20 sample history
        chi2Tolerance   = 0.001;            // Tolerate Chi^2 error under...
        minimumSlope    = 0.01;             // Minimum slope for timestamp
        timeThresh      = 0.0;              // Suggest restart after holding bad sync for _ seconds
        verbosity       = 1;                // Debugging output level (0=almost none)
        gui             = false;
    }
}

cameraCalibration {
    // The following camera calibration parameters should convert a vector with Z
    // pointing OUT of the camera and X "horizontal" (standard camera coordinate frame)
    // given the measured servo angles.  The transformation is written here in order
    // including the necessary servo angles
    //
    // IMPORTANT NOTES
    //   Note #1: Servo coordinate systems are on the axis at the servo face with an AX12 label
    //
    //   Note #2: The original intention was that these transformations are applied exactly in order
    //              e.g. translate(poseToPan), rotate(poseToPan), translate(panToTilt), rotate...
    //            If applied via a 4x4 RBT, rotations will occur first, yielding an incorrect end
    //            result.  We should fix this, but it's not important enough to do before magic
    //            PLEASE mark your code with a relevant note
    //
    extrinsics {
        // 1) coordinate transform from pose to pan servo axis
        poseToPan {
            position = [0.206375, 0, 0.5953];   // pose to pan servo translation
            rollpitchyaw_degrees = [0, 0, 0];   // "    "  "   "     rotations
        }
        // 2) measurement: pan servo angle
        // 3) coordinate transform from pan servo axis to tilt servo axis
        panToTilt {
            position = [0, 0.0206375, 0.044];   // pan servo to tilt servo translation
            rollpitchyaw_degrees = [-90, 0, 0]; // "   "     "  "    "     rotations
        }
        // 4) measurement: tilt servo angle
        // 5) coordinate transformation from tilt servo to camera center
        tiltToCam {
            position = [0, -0.038, -.0206375];  // tilt servo to camera translation
            rollpitchyaw_degrees = [0, 90, 0];  // "    "     "  "      rotation
        }
        // Result: transformation from camera coordinate frame (z out, y down)
        //   to robot coordinate frame (rear axel center on ground)
    }

    servo_error_deg {
        ids  = [   2,     3,     4,     5,     6,     7,     8,     9,    10,    11,    12,    13,    14,    15 ];
        pan  = [ 0.0,   0.0,   0.0,   0.0,  -2.2,   0.0,   0.0,  -1.9,   0.0,  -2.0,   0.0,   0.0,  -3.0,   0.0 ];
        tilt = [ 0.0,   0.0,   0.0,   0.0,   5.7,   0.0,   0.0,  -0.4,   0.0,   4.0,   0.0,   0.0,   3.0,   0.0 ];
    }

    // camera calibration parameters for CalTech camera calibration toolbox
    // determined on robot #2 on June 3rd, 2010
    intrinsics {
        fc = [477.73045, 478.72077];            // focal length
        cc = [393.83418, 256.00990];            // principal point
        kc = [-0.27777, 0.08649, 0.00082,       // distortion (combined radial/tangential model)
               0.00093, 0.00000];
        skew = 0;                               // skew

        // error terms (just to have available)
        //kc_err = [1.21183, 1.22115];
        cc_err = [1.99970, 1.55518];

        kc_err = [0.00328, 0.00430, 0.00037, 0.00031, 0.00000];
        pixel_err = [0.40137, 0.26483];
    }
}

tag_detection {
    verbose            = false;
    channel            = "TAG_DETECTIONS";// publishing channel
    follow_enable_dflt = true;   // only used by CameraFollower

    tag {                                       // TagDetector settings
        family      = "Tag36h11";               // tag family for detections
        size_m      = 0.11;

        segSigma    = 1;
        sigma       = 0;
        minMag      = 0.004;
        maxEdgeCost_deg = 30;
        magThresh   = 2000;
        thetaThresh = 100;
        errorBits   = 0;
        weightScale = 100;
        decimate    = false;
    }

    pxRadiusMax     = 200;                      // pixel radius from optical center for tag detections

    // robots {
    //     tagSize_m       = 0.137;                    // tag width for homographyToPose transformations
    //     rangeLimit      = 2.0;                      // range limit for tag detections
    // }
}

camera_driver {
    original {
        // not a substitue for im.getWidth()!!!
        // here in case we want to scale back up thumbnails from logs
        width = 752;
        height = 480;
    }

    ooiverifier {
        verbose = true;
        chatty = false;
        saveImages = false;
        neutralizeTime_millis = 40000;
        geom_lifetime_s = 60;
    }

    pan_tilt_servos {
        verbose = false;
        pan_scan_speed = 0.1;
        scan = false;        // scan servos when nothing else to do.
    }

    cameratracker {
        publish_images = false; // this will publish raw images on LCM!

        timeout = 1500;

        speed   = 1.0;
        pan_positions_deg  = [  0, -45, -90, -45,   0,  45,  90,  45];
        tilt_positions_deg = [ 10,  10,  10,  10,  10,  10,  10,  10];
        wait_time_ms       = 150;
        angle_tolerance_deg = 5;
    }

    priority {
        gamepad             = 0;
        neutralize          = 5;
        followme            = 10;
        ooitracker          = 20;
        cameratracker       = 30;
        image_streamer      = 40;
    }
}


safety_monitor {
    tasks_without_monitoring = [6];     // do not monitor in these tasks
}

obstacle {
    use_flat_world = true;              // Use flat world hazard detector

    obstacle_dz_threshold = 0.10;       // dz (meters) that signals and obstacle
    num_buckets_obs_thresh = 7;         // number of buckets full to signal obstacle

    // max_slope of 0.26 is tan(15degrees) (the ramps for contest) (use 0.1 for no ramps)
    // 0.3 is for 16.7degrees (slightly more than 15 degree ramps...
    max_slope = 0.35 ;                   // slope (dy/dx) used for obstacle detection
    max_z_obstacle = 0.5;
    prob_keep_obstacles = 0.90;          // probability of keeping historical costs

    num_iterations = 20;                 // number of iterations through mrf loop
    num_history_sweeps = 50;             // number of historical sweeps to keep around for terrain data


    // XXX Our current dumb flat-world obstacle params
    min_height = .05;
    max_height = 1.0;

}

pathControl { // See control.Params for details
    maxLookahead_m = 0.60;
    minLookahead_m = 0.4;//0.10;

    speedPreview_m = 1.5;
    previewDistThresh_m = 0.3;

    maxSpeed_p = 0.95;
    minSpeed_p = 0.35;

    turnRatio_p = 12.0;

    turnInPlaceThresh_deg = 30;
    slowdownDist_m = 0.50;
    destTolerance_m = 0.15;
    minMotorSpeed_p = 0.01;

    minSampleRate_m = 0.02;
    broom_lookahead_m = .6;
    broom_width_m = .6;

    useUnknownChecking = "false";

    path_timeout_s = 1.0;
}

control {
    spoofMode = false;
}

mapRelay {
    terrainChannel = "TERRAIN_MAP_CURRENT"; // No history
    // terrainChannel = "TERRAIN_MAP"; // With history
}

// XXX This may need to change for MX servos
HOKUYO_LIDAR {
    position = [ 0.266, 0.0, 0.584];        // Robot coords of the servo (main axis) at attachment
    rollpitchyaw_degrees = [0,0,0];         // Orientation of servo relative to robot frame

    max_range = 29.5;
    min_range = 0.5; // prevent us from seeing the robot itself.
    zoffset = 0.026; // height from hokuyo optical center to servo

    continuous_scan = true;                //  Continuously scan or wait for request. [MUST BE TRUE RIGHT NOW]

    // hallucinated points filtering terms
    filter {
        enable          = true;
        minDistance     = 0.20;             // required spacing between points before colinearity is considered
        minProjection   = 0.02;             // projection error allowed such that a point is considered colinear
    }
}

// priority 5 = STATUS message, lower will get spoken no matter what
// priority 5 messages will get skipped if they are old, except the last one
// Note: 5 is the weakest priority -- it is reserved for status messages
espeak {
    priority_thresh = 5;                    // messages above this threshold don't get spoken
    voice_logging = "english";
    priority_logging = 4;
    voice_task = "english";
    priority_status = 5;                    // For any sort of status message

    pronunciation = [ "(?i)status" "stadus"
        "(?i)lidar" "lye-dar"
	"(?i)nmea" "N M E A" ];

    set_volume = true;
}

// === Real time simulation stuff begins here ===
monte_carlo {
    // Search parameters
    iterative_deepening = false;
    max_search_depth = 8;
    num_exploration_samples = 10;
    num_evaluation_samples = 50;

    start_search_depth = 3; // XXX Currently unused

    // Robot parameters
    default_steps_per_second = 5;
    steps_per_second = 20;  // Ignore right now?
    default_forward_search_time = 60.0; // [s] XXX
    step_degrees = 3;
    min_degrees = -90; //-135;
    max_degrees = 90; //135;
    max_range = 29.9;
}
